from typing import List, Literal, Optional, Tuple, Union, overload

from ..evaluable import Evaluable
from ..constants import ACTIVE, CHANNEL_TYPE, POSITION, DATA
from .attributes.float_attribute import FloatAttribute
from .plugin import Plugin
from .sample import Sample

class ChannelBase(Evaluable):

  def bytes_to_seconds(self, bytes: int) -> float: ...
  def free(self): ...
  def get_data(self, length: int, format: DATA = DATA.SRC) -> bytes: ...
  def get_length(self, mode: int = ...) -> int: ...
  def get_levels(self, length: float, flags: int) -> List[float]: ...

  @overload
  def get_position(self, mode: Literal[POSITION.MUSIC_ORDER], decode: bool = ...) -> Tuple[int, int]: ...
  @overload
  def get_position(self, mode: POSITION = ..., decode: bool = ...) -> Union[int, Tuple[int, int]]: ...
  def lock(self) -> bool: ...
  def pause(self) -> bool: ...
  def seconds_to_bytes(self, secs: float) -> int: ...
  def stop(self) -> bool: ...
  def unlock(self) -> bool: ...

  @property
  def default_frequency(self) -> int: ...
  
  @property
  def channels(self) -> int: ...
  
  @property
  def type(self) -> CHANNEL_TYPE: ...
  
  @property
  def resolution(self) -> int: ...
  
  @property
  def plugin(self) -> Optional[Plugin]: ...
  
  @property
  def sample(self) -> Optional[Sample]: ...
  
  @property
  def level(self) -> Tuple[int, int]: ...
  
  @property
  def active(self) -> ACTIVE: ...
  
  @property
  def data_available(self) -> int: ...
  
  @property
  def flags(self) -> int: ...

  @property
  def frequency(self) -> FloatAttribute: ...

  @property
  def granularity(self) -> FloatAttribute: ...

  @property
  def pan(self) -> FloatAttribute: ...

  @property
  def src(self) -> FloatAttribute: ...

  @property
  def volume(self) -> FloatAttribute: ...
